<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Advanced-dynamic-simulations by Haboric-Hu</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Advanced-dynamic-simulations</h1>
      <h2 class="project-tagline"></h2>
      <a href="https://github.com/Haboric-Hu/advanced-dynamic-simulations" class="btn">View on GitHub</a>
      <a href="https://github.com/Haboric-Hu/advanced-dynamic-simulations/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/Haboric-Hu/advanced-dynamic-simulations/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h2>
<a id="advanced-dynamic-simulations" class="anchor" href="#advanced-dynamic-simulations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Advanced Dynamic Simulations</h2>

<p>Student Names: Anbang Hu, Yang Yu</p>

<p><em>Note</em>: Proposal can be found <a href="https://github.com/Haboric-Hu/advanced-dynamic-simulations/blob/master/formula/Advanced%20Dynamic%20Simulations%20-%20Proposal.pdf">here</a>. When writing proposal, we did not present in great details what we intended to do, because we had few clue on what was actually coming in this project. As we proceed, the whole picture starts to emerge. Thus, we present detailed tasks in this writeup. </p>

<h3>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview</h3>

<p>We have implemented forward Euler and simplectic Euler in <a href="http://15462.courses.cs.cmu.edu/fall2016/article/28">A4</a>. In this project, we implement <a href="https://math.la.asu.edu/%7Edajones/class/275/ch2.pdf">improved Euler and backward Euler</a> within the framework of Scotty3D.</p>

<h3>
<a id="enhanced-viewer" class="anchor" href="#enhanced-viewer" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Enhanced Viewer</h3>

<p>In order to visualize the effects from advanced solvers, we enhance the viewer from <a href="http://15462.courses.cs.cmu.edu/fall2016/article/28">A4</a> in the following way:</p>

<ul>
<li>We add <code>Action::Heat</code> to the viewer to allow users  to simulate heat diffusion on objects.</li>
<li>We also modify the viewer to allow users to use 

<ol>
<li>improved Euler for wave equation</li>
<li>backward Euler for wave equation</li>
<li>backward Euler for heat equation</li>
</ol>
</li>
</ul>

<p>The modification is done in <code>application.h</code>, <code>application.cpp</code>.</p>

<h3>
<a id="wave-equation" class="anchor" href="#wave-equation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Wave Equation</h3>

<h4>
<a id="forward-euler" class="anchor" href="#forward-euler" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Forward Euler</h4>

<p>We saw from <a href="http://15462.courses.cs.cmu.edu/fall2016/article/28">A4</a> that forward Euler is not stable. A slight initial offset at the left buttock of the bunny
<img src="https://github.com/Haboric-Hu/advanced-dynamic-simulations/blob/master/figures/bunny_with_initial_offset.png?raw=true" alt="Initial offset"></p>

<p>blows up the mesh:
<img src="https://github.com/Haboric-Hu/advanced-dynamic-simulations/blob/master/figures/forward_euler_wave_bunny.png?raw=true" alt="Foward Euler (Wave)"></p>

<h4>
<a id="improved-euler" class="anchor" href="#improved-euler" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Improved Euler</h4>

<p>Fortunately, we can improve forward Euler by taking into account of both derivatives at current timestep and next timestep. The formulation for improved Euler for wave equation can be found <a href="https://github.com/Haboric-Hu/advanced-dynamic-simulations/blob/master/formula/Wave_Equation_With_Improved_Euler.pdf">here</a>.</p>

<p>We code up improved Euler for wave equation in <code>Mesh::improved_euler_wave()</code> in <code>mesh.cpp</code>:
1. calculate new velocity based on current offset and velocity for each vertex and store them in temporary variables,
2. calculate new offset based on current offset, current velocity and new velocity for each vertex and store them in temporary variables,
3. update velocity and offset for each vertex.</p>

<p>Although running for a sufficiently long time still blows up the mesh, running for the same duration as in section Forward Euler gives better result:
<img src="https://github.com/Haboric-Hu/advanced-dynamic-simulations/blob/master/figures/improved_euler_wave_bunny.png?raw=true" alt="Improved Euler (Wave)"></p>

<h4>
<a id="backward-euler" class="anchor" href="#backward-euler" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Backward Euler</h4>

<p>Improved Euler does not seem to always give stable results. In this section, we look at a more powerful update rule called backward Euler, which is unconditionally stable.</p>

<p>Backward Euler update rule is</p>

<pre><code>u(k+1) = u(k) + tau * u'(k+1)
</code></pre>

<p>Since <code>u(k+1)</code> appears on both side of the equation, we need to solve an algebraic equation for <code>u(k+1)</code>.</p>

<p>There are numerous ways to solve backward Euler. We experiment on two of them:</p>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Fixed-point_iteration">fixed point iteration</a></li>
<li><a href="https://en.wikipedia.org/wiki/Newton%27s_method">Newton–Raphson method</a></li>
</ul>

<h4>
<a id="fixed-point-iteration" class="anchor" href="#fixed-point-iteration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Fixed Point Iteration</h4>

<p>We describe fixed point iteration for wave equation <a href="https://github.com/Haboric-Hu/advanced-dynamic-simulations/blob/master/formula/Wave_Equation_With_Backward_Euler__Fixed_Point_Iteration_.pdf">here</a> and implement it in <code>Mesh::backward_euler_fixedpoint_wave()</code> in <code>mesh.cpp</code>:
1. create temporary variables to store current velocity and offset for each vertex,
2. for vertex <code>v</code>, calculate new velocity based on current velocity, <code>v-&gt;offset</code> and <code>v-&gt;velocity</code> and store it in <code>v-&gt;velocity</code>,
3. for vertex <code>v</code>, calculate new offset based on current offset, <code>v-&gt;velocity</code>,
4. run step 2 and step 3 for several times.</p>

<p>Even with large initial offset, the result from fixed point iteration is rather smooth:
<img src="https://github.com/Haboric-Hu/advanced-dynamic-simulations/blob/master/figures/backward_euler_fixedpoint_bunny.png?raw=true" alt="Backward Euler Fixed Point (Wave)"></p>

<h4>
<a id="newtonraphson-method" class="anchor" href="#newtonraphson-method" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Newton–Raphson method</h4>

<p>We descibe Newton-Raphson method for wave equation here and implement it in <code>Mesh::backward_euler_newton_wave()</code> in <code>mesh.cpp</code>:</p>

<p><strong>TODO</strong> implementation details and result</p>

<p><em>Note</em>: Though stable, both fixed point iteration and Newton-Raphson are iterative methods. They need to run several iteration for each vertex update, which slows down the computation, which in turn slows down the video playback.</p>

<h3>
<a id="heat-equation" class="anchor" href="#heat-equation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Heat Equation</h3>

<p>Results from wave equation suggests that backward Euler works better than other update rules. We focus on ONLY <strong>backward Euler</strong> for heat equation, and explore both iterative methods and matrix method:</p>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Fixed-point_iteration">fixed point iteration (iterative)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Newton%27s_method">Newton–Raphson method (iterative)</a></li>
<li><a href="http://www.cs.cmu.edu/%7Ekmcrane/Projects/DGPDEC/paper.pdf">matrix method</a></li>
</ul>

<p>To support heat equation, we 
1. add a field <code>temperature</code> at each vertex;
2. initialize <code>temperature</code> to zero at vertex creation;
3. modify <code>Vertex::laplacian</code> to allow computing discrete laplacian for heat equation,
4. <strong>TODO</strong> add <code>draw_color</code> to color the mesh;
5. <strong>TODO</strong> add functionality to allow users to select a vertex and adjust its temperature.</p>

<h4>
<a id="fixed-point-iteration-1" class="anchor" href="#fixed-point-iteration-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Fixed Point Iteration</h4>

<p>We describe fixed point iteration for heat equation <a href="https://github.com/Haboric-Hu/advanced-dynamic-simulations/blob/master/formula/Heat_Equation_With_Backward_Euler__Fixed_Point_Iteration_.pdf">here</a>. We implement it in <code>Mesh::backward_euler_fixedpoint_heat()</code> in <code>mesh.cpp</code>:
1. create temporary variables to store current temperature for each vertex,
2. calculate new temperature for each vertex <code>v</code> based on current temperature and <code>v-&gt;temperature</code>, and store it in <code>v-&gt;temperature</code>,
3. run step 2 for several times.</p>

<p><strong>TODO</strong> present result</p>

<h4>
<a id="newton-raphson-method" class="anchor" href="#newton-raphson-method" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Newton-Raphson Method</h4>

<p>We describe Newton-Raphson for heat equation here. We implement it in <code>Mesh::backward_euler_newton_heat()</code> in <code>mesh.cpp</code>:</p>

<p><strong>TODO</strong> implementation details and result</p>

<h4>
<a id="power-of-matrix" class="anchor" href="#power-of-matrix" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Power of Matrix</h4>

<p>As mentioned above, backward Euler implemented using an iterative method tends to be fairly slow. One way to speed it up is to assemble everything into a matrix and solve a big linear system.</p>

<p>We describe backward Euler with matrix method for heat equation <a href="https://github.com/Haboric-Hu/advanced-dynamic-simulations/blob/master/formula/Heat_Equation_With_Backward_Euler__Solving_Linear_Systems_.pdf">here</a>. We follow the idea in the section titled "Meshes and Matrices" in these <a href="http://www.cs.cmu.edu/%7Ekmcrane/Projects/DGPDEC/paper.pdf">course notes</a> as well as linear algebra package <a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen</a> to implement it in <code>Mesh::backward_euler_matrix_heat()</code> in <code>mesh.cpp</code>:</p>

<ol>
<li>Assign unique index to the vertices in the mesh;</li>
<li>Build the Laplace and mass matrice (sparse matrix) according to the indices of the vertices;</li>
<li>Solve the linear system that describes the backward Euler update rule.</li>
</ol>

<p><strong>TODO</strong> present result</p>

<h3>
<a id="conclusion" class="anchor" href="#conclusion" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Conclusion</h3>

<p>In this project, we implement advanced solvers for both wave equation and heat equation. We see that improved Euler gives a slightly more stable result than forward Euler, whereas backward Euler produces the most smooth result. However, iterative approximation for backward Euler is slow. Whenever possible, it is faster to implement backward Euler by first converting the problem into a linear system represented as sparse matrix and then solve it.</p>

<h3>
<a id="references" class="anchor" href="#references" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>References</h3>

<p>We list all the references we have used in the following:</p>

<ul>
<li><a href="http://15462.courses.cs.cmu.edu/fall2016/article/28">Computer Graphics Assignment 4</a></li>
<li><a href="https://math.la.asu.edu/%7Edajones/class/275/ch2.pdf">Numerical Approximations</a></li>
<li><a href="https://en.wikipedia.org/wiki/Fixed-point_iteration">Wiki: Fixed Point Iteration</a></li>
<li><a href="https://en.wikipedia.org/wiki/Newton%27s_method">Wiki: Newton's Method</a></li>
<li><a href="http://www.cs.cmu.edu/%7Ekmcrane/Projects/DGPDEC/paper.pdf">Discrete Differential Geometry: An Applied Introduction</a></li>
<li><a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen</a></li>
</ul>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/Haboric-Hu/advanced-dynamic-simulations">Advanced-dynamic-simulations</a> is maintained by <a href="https://github.com/Haboric-Hu">Haboric-Hu</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
